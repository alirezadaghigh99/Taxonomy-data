output file:
processed_korniadepth_from_point312.json
function:
depth_from_point
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] FAILED', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] FAILED', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3]', 'FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED', '../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] FAILED'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'openxla', 'onnxrt', 'tvm', 'cudagraphs', 'inductor', None, 'jit'}
model weights cached: ['checkpoints']

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1
collecting ... collected 11 items

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED

=================================== FAILURES ===================================
________ TestMotionFromEssentialChooseSolution.test_smoke[cpu-float32] _________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d7702380>
device = device(type='cpu'), dtype = torch.float32

    def test_smoke(self, device, dtype):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(1, 1, 2, device=device, dtype=dtype)
        x2 = torch.rand(1, 1, 2, device=device, dtype=dtype)
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.6092, 0.6367, 0.8732],
         [0.7500, 0.6670, 0.6903],
         [0.6718, 0.4035, 0.9435]]])
K1 = tensor([[[[0.6337, 0.6433, 0.0676],
          [0.2286, 0.3099, 0.1820],
          [0.1641, 0.5857, 0.4979]],

        ...4979]],

         [[0.6337, 0.6433, 0.0676],
          [0.2286, 0.3099, 0.1820],
          [0.1641, 0.5857, 0.4979]]]])
K2 = tensor([[[[0.9978, 0.3041, 0.4501],
          [0.5476, 0.9983, 0.5911],
          [0.7214, 0.4988, 0.9172]],

        ...9172]],

         [[0.9978, 0.3041, 0.4501],
          [0.5476, 0.9983, 0.5911],
          [0.7214, 0.4988, 0.9172]]]])
x1 = tensor([[[[0.3866, 0.7860]],

         [[0.3866, 0.7860]],

         [[0.3866, 0.7860]],

         [[0.3866, 0.7860]]]])
x2 = tensor([[[[0.5145, 0.6786]],

         [[0.5145, 0.6786]],

         [[0.5145, 0.6786]],

         [[0.5145, 0.6786]]]])
mask = None

    def motion_from_essential_choose_solution(
        E_mat: torch.Tensor,
        K1: torch.Tensor,
        K2: torch.Tensor,
        x1: torch.Tensor,
        x2: torch.Tensor,
        mask: Optional[torch.Tensor] = None,
    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        r"""Recover the relative camera rotation and the translation from an estimated essential matrix.
    
        The method checks the corresponding points in two images and also returns the triangulated
        3d points. Internally uses :py:meth:`~kornia.geometry.epipolar.decompose_essential_matrix` and then chooses
        the best solution based on the combination that gives more 3d points in front of the camera plane from
        :py:meth:`~kornia.geometry.epipolar.triangulate_points`.
    
        Args:
            E_mat: The essential matrix in the form of :math:`(*, 3, 3)`.
            K1: The camera matrix from first camera with shape :math:`(*, 3, 3)`.
            K2: The camera matrix from second camera with shape :math:`(*, 3, 3)`.
            x1: The set of points seen from the first camera frame in the camera plane
              coordinates with shape :math:`(*, N, 2)`.
            x2: The set of points seen from the first camera frame in the camera plane
              coordinates with shape :math:`(*, N, 2)`.
            mask: A boolean mask which can be used to exclude some points from choosing
              the best solution. This is useful for using this function with sets of points of
              different cardinality (for instance after filtering with RANSAC) while keeping batch
              semantics. Mask is of shape :math:`(*, N)`.
    
        Returns:
            The rotation and translation plus the 3d triangulated points.
            The tuple is as following :math:`[(*, 3, 3), (*, 3, 1), (*, N, 3)]`.
        """
        KORNIA_CHECK_SHAPE(E_mat, ["*", "3", "3"])
        KORNIA_CHECK_SHAPE(K1, ["*", "3", "3"])
        KORNIA_CHECK_SHAPE(K2, ["*", "3", "3"])
        KORNIA_CHECK_SHAPE(x1, ["*", "N", "2"])
        KORNIA_CHECK_SHAPE(x2, ["*", "N", "2"])
        KORNIA_CHECK(len(E_mat.shape[:-2]) == len(K1.shape[:-2]) == len(K2.shape[:-2]))
    
        if mask is not None:
            KORNIA_CHECK_SHAPE(mask, ["*", "N"])
            KORNIA_CHECK(mask.shape == x1.shape[:-1])
    
        unbatched = len(E_mat.shape) == 2
    
        if unbatched:
            # add a leading batch dimension. We will remove it at the end, before
            # returning the results
            E_mat = E_mat[None]
            K1 = K1[None]
            K2 = K2[None]
            x1 = x1[None]
            x2 = x2[None]
            if mask is not None:
                mask = mask[None]
    
        # compute four possible pose solutions
        Rs, ts = motion_from_essential(E_mat)
    
        # set reference view pose and compute projection matrix
        R1 = eye_like(3, E_mat)  # Bx3x3
        t1 = vec_like(3, E_mat)  # Bx3x1
    
        # compute the projection matrices for first camera
        R1 = R1[:, None].expand(-1, 4, -1, -1)
        t1 = t1[:, None].expand(-1, 4, -1, -1)
        K1 = K1[:, None].expand(-1, 4, -1, -1)
        P1 = projection_from_KRt(K1, R1, t1)  # 1x4x4x4
    
        # compute the projection matrices for second camera
        R2 = Rs
        t2 = ts
        K2 = K2[:, None].expand(-1, 4, -1, -1)
        P2 = projection_from_KRt(K2, R2, t2)  # Bx4x4x4
    
        # triangulate the points
        x1 = x1[:, None].expand(-1, 4, -1, -1)
        x2 = x2[:, None].expand(-1, 4, -1, -1)
        X = triangulate_points(P1, P2, x1, x2)  # Bx4xNx3
    
        # project points and compute their depth values
        d1 = depth_from_point(R1, t1, X)
        d2 = depth_from_point(R2, t2, X)
    
        # verify the point values that have a positive depth value
        depth_mask = (d1 > 0.0) & (d2 > 0.0)
        if mask is not None:
            depth_mask &= mask.unsqueeze(1)
    
>       mask_indices = torch.max(depth_mask.sum(-1), dim=-1, keepdim=True)[1]
E       TypeError: max() received an invalid combination of arguments - got (numpy.ndarray, keepdim=bool, dim=int), but expected one of:
E        * (Tensor input, *, Tensor out = None)
E             didn't match because some of the keywords were incorrect: keepdim, dim
E        * (Tensor input, Tensor other, *, Tensor out = None)
E        * (Tensor input, int dim, bool keepdim = False, *, tuple of Tensors out = None)
E        * (Tensor input, name dim, bool keepdim = False, *, tuple of Tensors out = None)

../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:530: TypeError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-1-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d7702830>
batch_size = 1, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[ 0.19266565],
          [-0.1960303 ],
          [-0.34563777]],

         [[ 0.10946199],
          [-0.14...         [-0.4782426 ]],

         [[ 0.77243364],
          [-0.77379644],
          [-1.215041  ]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (1,4,3,3)->(1,4,newaxis,newaxis) (1,4,3,3,1)->(1,4,3,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d7702770>
batch_size = 2, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         ...  [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[ 4.3006974e-01],
          [ 8.5609984e-01],
          [-5.0914961e-01]],

         [[ 7.0884180e-01],
    ....1516623e+00]],

         [[ 3.1523207e-01],
          [-1.0500848e+00],
          [-3.2179469e-01]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (2,4,3,3)->(2,4,newaxis,newaxis) (2,4,3,3,1)->(2,4,3,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-8] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d7702b30>
batch_size = 2, num_points = 8, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         ...  [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[ 0.27029917],
          [-0.20918274],
          [ 0.55347365]],

         [[ 0.30578196],
          [-0.66...         [ 0.07342345]],

         [[-0.2893639 ],
          [ 0.14612246],
          [ 0.16766304]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (2,4,3,3)->(2,4,newaxis,newaxis) (2,4,8,3,1)->(2,4,8,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-3-2] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d7702bf0>
batch_size = 3, num_points = 2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         ...  [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[ 4.2906588e-01],
          [ 2.0952788e-01],
          [-1.0731500e+00]],

         [[-3.3365913e-02],
    ....8101236e-01]],

         [[-9.8417777e-01],
          [ 3.4136811e-01],
          [ 2.4111946e-01]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (3,4,3,3)->(3,4,newaxis,newaxis) (3,4,2,3,1)->(3,4,2,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
_______ TestMotionFromEssentialChooseSolution.test_masking[cpu-float32] ________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d7702ec0>
device = device(type='cpu'), dtype = torch.float32

    def test_masking(self, device, dtype):
        E_mat = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(2, 10, 2, device=device, dtype=dtype)
        x2 = torch.rand(2, 10, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[:, 1:-1, :], x2[:, 1:-1, :])

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         ...  [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[ 9.4193870e-01],
          [-2.4232799e-01],
          [-7.1225500e-01]],

         [[ 1.0254003e+00],
    ....1085193e-01]],

         [[ 9.7455609e-01],
          [-2.8752682e+00],
          [-3.0140728e-01]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (2,4,3,3)->(2,4,newaxis,newaxis) (2,4,8,3,1)->(2,4,8,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-10] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d77032b0>
num_points = 10, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[-5.250317  ],
          [ 4.3637505 ],
          [-1.3596591 ]],

         [[-0.22368589],
          [-0.18...         [ 0.7907489 ]],

         [[-0.4403362 ],
          [ 0.22777244],
          [-0.03063868]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (1,4,3,3)->(1,4,newaxis,newaxis) (1,4,8,3,1)->(1,4,8,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-15] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d77031f0>
num_points = 15, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[-4.13967818e-01],
          [-1.19683750e-01],
          [ 1.77196190e-01]],

         [[-6.48581982e-01],
...25856e-01]],

         [[ 1.74785972e+00],
          [ 7.05184937e-01],
          [-8.97706866e-01]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (1,4,3,3)->(1,4,newaxis,newaxis) (1,4,13,3,1)->(1,4,13,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-20] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d77034f0>
num_points = 20, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[ 0.03145967],
          [ 0.19894592],
          [-0.23756814]],

         [[-0.02032119],
          [-0.28...         [-0.05548199]],

         [[-0.40724656],
          [-0.22508048],
          [ 0.04584001]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (1,4,3,3)->(1,4,newaxis,newaxis) (1,4,18,3,1)->(1,4,18,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
_______ TestMotionFromEssentialChooseSolution.test_two_view[cpu-float32] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d77037c0>
device = device(type='cpu'), dtype = torch.float32

    def test_two_view(self, device, dtype):
        scene = generate_two_view_random_scene(device, dtype)
    
        E_mat = epi.essential_from_Rt(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
    
        R, t = epi.relative_camera_motion(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
        t = torch.nn.functional.normalize(t, dim=1)
    
>       R_hat, t_hat, _ = epi.motion_from_essential_choose_solution(
            E_mat, scene["K1"], scene["K2"], scene["x1"], scene["x2"]
        )

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:482: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = array([[[[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
 ...., 0.],
         [0., 0., 1.]],

        [[1., 0., 0.],
         [0., 1., 0.],
         [0., 0., 1.]]]], dtype=float32)
t = array([[[[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]],

        [[0.],
         [0.],
         [0.]]]], dtype=float32)
X = array([[[[[ 3.3255607e-01],
          [-5.2902251e-01],
          [-8.9441252e-01]],

         [[ 3.8008562e-01],
    ....9782920e+00]],

         [[-5.4616213e-01],
          [ 4.2015824e-01],
          [ 1.0530546e+00]]]]], dtype=float32)

    def depth_from_point(R, t, X):
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
           R: The rotation matrix with shape (*, 3, 3).
           t: The translation vector with shape (*, 3, 1).
           X: The 3d points with shape (*, 3).
    
        Returns:
           The depth value per point with shape (*, 1).
        """
        R = np.asarray(R)
        t = np.asarray(t)
        X = np.asarray(X)
        assert R.shape[-2:] == (3, 3), 'Rotation matrix R must have shape (*, 3, 3)'
        assert t.shape[-2:] == (3, 1), 'Translation vector t must have shape (*, 3, 1)'
        assert X.shape[-1] == 3, '3D points X must have shape (*, 3)'
        X = X[..., np.newaxis]
>       X_transformed = np.matmul(R, X) + t
E       ValueError: operands could not be broadcast together with remapped shapes [original->remapped]: (1,4,3,3)->(1,4,newaxis,newaxis) (1,4,30,3,1)->(1,4,30,newaxis,newaxis)  and requested shape (3,1)

../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
__________ TestMotionFromEssentialChooseSolution.test_gradcheck[cpu] ___________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7820d7703a90>
device = device(type='cpu')

    def test_gradcheck(self, device):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=torch.float64, requires_grad=True)
        K1 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        K2 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        x1 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
        x2 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
    
>       self.gradcheck(
            epi.motion_from_essential_choose_solution,
            (E_mat, K1, K2, x1, x2),
            requires_grad=(True, False, False, False, False),
        )

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
../publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
../publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
../publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
../publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:25: in depth_from_point
    X = np.asarray(X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = tensor([[[[ 0.6112,  0.3941, -0.5441],
          [ 1.8840,  0.3250, -0.4362]],

         [[-0.6112, -0.3941,  0.5441],....9231, -0.5518,  0.7836],
          [-1.4404, -0.2459,  0.3308]]]], dtype=torch.float64,
       grad_fn=<MulBackward0>)
dtype = None

    def __array__(self, dtype=None):
        if has_torch_function_unary(self):
            return handle_torch_function(Tensor.__array__, (self,), self, dtype=dtype)
        if dtype is None:
>           return self.numpy()
E           RuntimeError: Can't call numpy() on Tensor that requires grad. Use tensor.detach().numpy() instead.

../publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/_tensor.py:1149: RuntimeError
=========================== short test summary info ============================
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]
FAILED ../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]
============================== 11 failed in 0.64s ==============================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'inductor', 'tvm', 'openxla', 'onnxrt', 'jit', 'cudagraphs', None}
model weights cached: ['checkpoints']

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1
collecting ... collected 11 items

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.21s ==============================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'cudagraphs', 'tvm', 'onnxrt', 'jit', 'inductor', 'openxla', None}
model weights cached: ['checkpoints']

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1
collecting ... collected 11 items

../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.20s ==============================
